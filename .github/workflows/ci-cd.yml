# .github/workflows/ci-cd.yml
name: NestJS Monorepo CI/CD

on:
  push:
    branches:
      - master # Trigger deployment on push to master
      - develop # Trigger CI on push to develop
  pull_request:
    branches:
      - master # Trigger CI on PRs targeting master
      - develop # Trigger CI on PRs targeting develop

jobs:
  # ==================
  # == CI Pipeline ===
  # ==================
  test-and-build:
    name: Test & Build
    runs-on: ubuntu-latest

    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Set up Node.js v20
        uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: 'npm'

      - name: Install Dependencies
        run: npm ci # Use clean install for CI

      #   - name: Run Linter Check
      #     run: npm run lint
      # Optional: Add formatting check if desired
      # - name: Check Formatting
      #   run: npm run format -- --check
      - name: Run Tests
        run: npm run test
        # Note: If tests require DB/NATS, you might need to start them here using Docker
        # Or mock dependencies effectively

      - name: Build Applications
        run: npm run build # Builds all apps and libs

  # =====================
  # == CD Pipeline ======
  # =====================
  deploy-to-vps:
    name: Deploy to VPS
    runs-on: ubuntu-latest
    needs: test-and-build # Run only if test-and-build succeeds
    if: github.event_name == 'push' && github.ref == 'refs/heads/master' # Deploy only on push to master

    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      # --- Docker Build Setup ---
      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      # --- Build and Save Docker Images ---
      # Login to a registry here if you prefer (e.g., GHCR)
      # uses: docker/login-action@v3
      # with:
      #   registry: ghcr.io
      #   username: ${{ github.actor }}
      #   password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build and Save api-gateway Image
        uses: docker/build-push-action@v6
        with:
          context: .
          file: ./apps/api-gateway/Dockerfile
          platforms: linux/amd64 # Specify target platform
          push: false # Don't push to registry, just build
          tags: nest-api-gateway:latest # Use the same tag as in docker-compose.deploy.yml
          outputs: type=docker,dest=/tmp/api-gateway.tar # Save as tar file
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Build and Save todo-service Image
        uses: docker/build-push-action@v6
        with:
          context: .
          file: ./apps/todo-service/Dockerfile
          platforms: linux/amd64
          push: false
          tags: nest-todo-service:latest
          outputs: type=docker,dest=/tmp/todo-service.tar
          cache-from: type=gha
          cache-to: type=gha,mode=max

      # --- Deploy to Server via SSH ---
      - name: Prepare Server .env File
        run: echo "${{ secrets.SERVER_ENV_FILE }}" > /tmp/server.env

      # --- Debug Step to Verify Files ---
      - name: Debug /tmp/ directory
        run: ls -l /tmp/

      # Copy files to VPS using scp-action
      - name: Copy Docker image - API Gateway
        uses: appleboy/scp-action@v0.1.4
        with:
          host: ${{ secrets.VPS_SSH_HOST }}
          port: ${{ secrets.VPS_SSH_PORT }}
          username: ${{ secrets.VPS_SSH_USER }}
          key: ${{ secrets.VPS_SSH_KEY }}
          source: '/tmp/api-gateway.tar'
          target: '/home/${{ secrets.VPS_SSH_USER }}/app/nest-microservices'

      - name: Copy Docker image - Todo Service
        uses: appleboy/scp-action@v0.1.4
        with:
          host: ${{ secrets.VPS_SSH_HOST }}
          port: ${{ secrets.VPS_SSH_PORT }}
          username: ${{ secrets.VPS_SSH_USER }}
          key: ${{ secrets.VPS_SSH_KEY }}
          source: '/tmp/todo-service.tar'
          target: '/home/${{ secrets.VPS_SSH_USER }}/app/nest-microservices'

      - name: Copy Deployment Files
        uses: appleboy/scp-action@v0.1.4
        with:
          host: ${{ secrets.VPS_SSH_HOST }}
          port: ${{ secrets.VPS_SSH_PORT }}
          username: ${{ secrets.VPS_SSH_USER }}
          key: ${{ secrets.VPS_SSH_KEY }}
          source: 'docker-compose.deploy.yml,/tmp/server.env'
          target: '/home/${{ secrets.VPS_SSH_USER }}/app/nest-microservices'
          rm: false

      - name: Deploy to VPS using SSH
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.VPS_SSH_HOST }}
          port: ${{ secrets.VPS_SSH_PORT }}
          username: ${{ secrets.VPS_SSH_USER }}
          key: ${{ secrets.VPS_SSH_KEY }}
          script: |
            # Define deployment directory on the server
            DEPLOY_DIR=/home/${{ secrets.VPS_SSH_USER }}/app/nest-microservices
            cd $DEPLOY_DIR

            # Rename .env file if needed
            if [ -f server.env ]; then
              mv server.env .env
            fi

            echo "Loading Docker images..."
            docker load -i api-gateway.tar
            docker load -i todo-service.tar

            echo "Removing temporary tar files..."
            rm api-gateway.tar todo-service.tar

            echo "Starting deployment with Docker Compose..."
            # Pull latest base images if needed (postgres, nats)
            docker compose -f docker-compose.deploy.yml pull postgres nats
            # Start new containers based on the loaded images and compose file
            docker compose -f docker-compose.deploy.yml up -d --remove-orphans

            echo "Running Prisma migrations..."
            # Wait a few seconds for the DB to be ready
            sleep 10
            # Execute migrations inside the running todo-service container
            docker compose -f docker-compose.deploy.yml exec -T todo-service npx prisma migrate deploy

            echo "Deployment completed!"

            # Clean up unused docker images
            echo "Cleaning up dangling Docker images..."
            docker image prune -f
